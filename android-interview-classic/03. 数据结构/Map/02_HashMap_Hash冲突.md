# hash冲突

## 概述

HashMap的hash冲突是指不同的键映射到相同的哈希桶。解决冲突的方法是使用链表或红黑树来存储相同哈希值的键值对，保证查找性能。

## 详述

在 `HashMap` 中，哈希冲突是指两个或多个键值对的键通过哈希函数计算出相同的哈希码，因此它们应该存储在哈希表的同一个位置。在 `HashMap` 的内部，哈希表用数组来实现，数组的每一个元素（即一个桶）保存一个链表。这些链表存储哈希码相同的条目（即键值对）。

### 处理哈希冲突的方法

#### 1. 链地址法（链表法）
在 JDK 1.8 之前的版本中，`HashMap` 主要通过链表来解决哈希冲突。当在同一个桶位置上的多个元素发生冲突时，它们被放在一个链表中。这些键值对（`Node`）通过链表中的下一个节点字段 `next` 相连接。

#### 2. 红黑树法
从 JDK 1.8 开始，当链表长度超过阈值（默认为 8）并且数组容量至少为 64，链表将转换为红黑树以减少查找时间。红黑树比链表具有更高的查找效率（`O(log n)` vs `O(n)`），但在插入和删除元素时相对较慢，因为它们需要重新平衡树和更新红/黑属性。当哈希桶的大小下降到 6 以下时，红黑树将退化回链表，以节省存储空间。

### 哈希冲突的影响
- **性能下降**：如果有太多的哈希冲突，查找时间可能接近线性查找时间 `O(n)`。然而，通过使用红黑树，查找时间可以保持在 `O(log n)`。
- **增加计算**：在哈希冲突的位置使用链表或红黑树意味着更多的计算会被用于插入、删除和查找键值对。
  
### 怎样减少哈希冲突
- **良好的哈希函数**：哈希函数的设计应尽可能保证键值对在桶数组中均匀分布。
- **动态扩展/缩减**：当键值对数量过多或过少时，`HashMap` 可以通过改变内部数组的大小（rehashing）来适应这些变化，并尽可能保持冲突数量的最小化。

### 示例
如果我们有两个字符串键 "AaAa" 和 "BBBB"，它们都产生相同的哈希码，这就是一个哈希冲突的例子。在这种情况下，`HashMap` 会在同一个桶（链表或红黑树）中存储这两个键值对。

```java
HashMap<String, String> map = new HashMap<>();
map.put("AaAa", "value1");
map.put("BBBB", "value2");
```
尽管 "AaAa" 和 "BBBB" 具有相同的哈希码，但 `HashMap` 仍然能够正确处理这种情况，因为它通过使用键的 `equals()` 方法来确保完全的唯一性。

总之，哈希冲突在所有哈希表中是无法避免的，但 `HashMap` 通过链表和红黑树等策略，很好地解决了这个问题。